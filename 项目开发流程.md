

# Vue-cli3.0+Element UI + NodeJs(Express+mongoose)+Mongodb全栈开发王者荣耀手机站
- 全站之巅老师本项目的 github → https://github.com/wxs77577/node-vue-moba

###	前台与后台与服务器的关系
- 前台是web前端主要的开发场所
> 后台不仅仅是js处理文件 也要有后台页面  这个后台页面也是通过前端技术vue+Element搭建的
> 前台页面和后台页面均可以对server端进行增删改查的请求  但后台页面控制前台页面的文章列表渲染结果   就像dede一样
> server端对后台路由的控制   对于项目接口比较多的请求 server端需要对路由router的接口进行封装处理
> server端下创建router文件夹专门存放对路由接口的处理   创建admin文件夹  表示处理后端的路由请求
> server端通过mongoose对mongodb的操作 对于数据库的请求封装为两部分 
> 一部分是对数据库的增删改查工作 增删改查和 mongoose的创建工作    在文件夹plugins/db.js中
> 一部分是对数据库的模型创建工作 Schema的创建与联查 在文件夹models中
> mongodb联查一般是通过相互关联的_id进行关联联查的  _id是别人的  关联的集合也是别人的

## 一、 入门

1.项目介绍
- 全栈之巅老师的王者荣耀开发项目   涵盖了前端后端数据库  用的是前端流行的vue node mongodb 这几项技术建议前端掌握 

2.项目技术选型
> 插件安装 			vue-cli3.0 node mongodb
> node.js 		地址:https://nodejs.org/en/
> npm     		淘宝镜像:http://npm.taobao.org/
> vue-cli3.0 	npm i -g @vue/cli
> mongodb 		地址:https://www.mongodb.com/ 注意下载Server服务器版本→选择版本 系统  类型→选择MSI安装版
> 编辑器 				VSCode HBuilder

3. 初始化项目
> READNE.md 项目介绍文档
> LICENSE		项目开源协议
> .gitignore git忽略文件
> 项目开发流程.md 项目开发文档

### 三端项目创建
- mkdir server     创建服务端
- vue create web   创建web端		选择默认配置  但要配路由  估计还要配vuex
- vue create admin 创建管理后台	选择默认配置  但要配路由

#### 前台文件夹为 web

####	后台文件夹为 admin
- 安装Element Ui组件
- 安装router  路由
- 安装axios   ajax请求库
- 安装vue2 editor 富文本编辑器

#### 服务器文件夹为 server
- 安装express
- 安装mongoose
- 安装cors   允许跨域请求的方法
- 安装inflection 处理接口的大小写和加复数后缀
- 安装multer 处理图片资源上传
- 安装 nodemon 方便开启node后台服务		npm i nodemon --save
- 安装 bcrypt 对用户的密码进行散列加密
- 安装jsonwebtoken 向浏览器返回一个token验证  和session一样
- 安装http-assert 用来处理错误请求的返回

#### 初始化server端项目
- npm init -y 生成package.json文件
- 在server目录下生成index.js文件夹
- 在package.json文件中配置  "scripts" 将npm run serve 作为server端的启动项  

	```js
  "serve": "nodemon index.js",
	```
	
- 通过 npm run serve 启动服务端接口  不配置就是 nodemon index.js启动
	
## 二、 管理后台

1. 基于Element UI的后台管理基础界面搭建
- 项目前台和后台的页面渲染都是通过vue+Element Ui实现的 其实这里的后台也能当作写前端的项目了  
> cd admin
> vue add element 
> vue add router
> 引入 Element Ui的 布局容器container组件  在src下的 views文件新建Main.vue组件存放后台管理的布局  Element Ui的地址是: https://element.eleme.cn/#/zh-CN/component/installation

- 在router.js文件中配置路由

	```js
	import Main from './views/Main.vue'
	{
    path: '/',
    name: 'main',
    component: Main
  },
	```
	
- 在Main.vue组件中设置容器的宽度和边框 让其全屏展示 vh是当前屏幕的比例 1vh就是1%的屏幕宽高

	```js
	<el-container style="height: 100vh;">
	```

### 1. 创建分类

#### 将导航一变为内容管理→ 将分组改为分类→ 再改新建分类 分类列表

	```js
	<el-menu-item-group>
    <template slot="title">分类</template>
    <el-menu-item index="1-1">新建分类</el-menu-item>
    <el-menu-item index="1-2">分类列表</el-menu-item>
  </el-menu-item-group>
	```
	
- 给<el-menu>标签添加router属性 使其变成一个可跳转的路由导航  这个和router-view标签作用类似

	```js
	<el-menu router :default-openeds="['1', '3']">
	```
	
- 修改<el-menu>下的<el-menu-item>标签 使其成为一个路由导航 个和router-link标签作用类似

	```js
	<el-menu-item index="/categories/create">新建分类</el-menu-item>
	<el-menu-item index="/categories/list">分类列表</el-menu-item>
	```

#### 创建CategoryEdit.vue组件 存放添加列表相关操作 

- 直接绑定了提交事件 save 并为表单设置了双向绑定  v-model="model.name"
	
	```html
	<template>
		<div class="about">
			<h1>新建分类</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<el-form-item label="名称">
			    <el-input v-model="model.name"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			data(){
				return {
					model: {},
				}
			},
			async save(){
				
			}
		}
	</script>
	```
	
- 在router中引入CategoryEdit.vue组件并挂载Main.vue下  因为他们都是在Main.vue上显示的

	```js
	import CategoryEdit from './views/CategoryEdit.vue'
	children: [
  	{ path: '/categories/create', component: CategoryEdit },
  ]
  ```
  
- 修改Main.vue中的 <el-main>标签将其内容更改为路由容器 就是右侧的路由展示区域

	```html
	<el-main>
  	<router-view></router-view>
  </el-main>
	```

- 在创建完基本的分类添加页面后 就需要向后台存储分类数据了  这里我们用的ajax库是axios 	
- 安装axios与server端进行交互  创建http.js 集中处理axios的请求  这里都是在http.js文件下管理的

	```js
	//引入axios
	import axios from 'axios'
	
	//创建一个axios实例
	const http = axios.create({
		//指向后台的接口地址
	  baseURL: 'http://localhost:3000/admin/api'
	})
	
	//默认导出
	export default http
	```
	
- 在main.js中引入http.js 并将其中的请求方法挂在到vue的原型上 这样可以通过$http使用http.js中的方法了

	```js
	import http from './http'
	Vue.prototype.$http = http	
	```
	
#### server后台开发

- 安装后台需要用到的插件 	npm i express@next mongoose cors  express开发node  mongoose操作mongodb cors实现node跨域请求
- 搭建基于express的基本http请求

	```js
	//引入express
	const express = require('express')
	
	//创建express实例
	const app = express()
	
	//开启端口
	app.listen(3000,()=>{
		console.log('http://localhost:3000')
	})
	```
	
- 创建routes文件夹  用来处理后台请求相关的路由因为比较多所以单独写到一个文件内   admin是后端路由   web是前端路由
- 创建一个最基本的路由接口请求	express.Router()意思是开启express的子路由 父路由就是那个localhost:3000 

	```js
	module.exports = app => {
		//引入express使用它的子路由Router()	
		const express = require('express')
		const router = express.Router()	
		
		//处理接口请求
		router.post('/catagories', async (req,res) => {
			
		})
		
		app.use('/admin/api',router)
	}
	```
	
- 使用mongodb数据库 对数据库的请求也进行模块化开发 不要写在一起避免耦合度过高
- 创建plugins/db.js文件夹用来处理数据库连接请求  这里没有加 'require-all' 后续开发用到的话记得加

	```js
	//连接数据库
	module.exports = app => {
	  const mongoose = require("mongoose")
	  mongoose.connect('mongodb://127.0.0.1:27017/node-vue-moba', {
	    useNewUrlParser: true
	  })
	}
	```
	
- 将server端处理后台接口请求和数据库连接的方法都挂在到server/index.js上

	```js
	//引入后端路由和数据库
	require('./routes/admin')(app)
	require('./plugins/db')(app)
	```	
	
- 创建mongodb模型 方便往数据库中存放数据
> 新建models文件夹 这里面存放的就是每个集合的模型规则 文件名就是集合的名字
- 先建一个Category.js文件用来指定分类数据的存放规则

	```js
	const mongoose = require('mongoose')
	
	const schema = new mongoose.Schema({
	  name: { type: String },
	})
	
	module.exports = mongoose.model('Category', schema)
	```
	
- 在routes/admin/index.js中引入这个集合模型 这个模型就是分类模型

	```js
	const Category = require('../../models/Category')
	```
	
- 接入了集合模型以后就可以存储数据了	

	```js
	//存储分类数据
	router.post('/categories', async (req,res) => {
		const model = await Category.create(req.body)
		res.send(model)
	})
	```
	
- 完善前端页面对这个接口的请求写法 用element ui的this.$message提示一下保存的状态 其实应该看一下res的返回状态 要看看是否提交成功了

	```js
	async save(){
		const res = await this.$http.post('categories', this.model)
		this.$router.push('/categories/list')
		this.$message({
      type: 'success',
      message: '保存成功'
    })
	}
	```	
	
- 开启admin服务器  开启server服务器 开启mongodb试一下接口通不通
> 通的话此时已经跳转到了列表页 先创建一个CategoryList.vue要不router里都挂不了  下面我们开始分类列表页的开发 

### 2. 分类列表

- 创建分类列表页面 CategoryList.vue 并将其挂载在到路由中

	```js
	import CategoryList from './views/CategoryList.vue'
	children: [
  	{ path: '/categories/create', component: CategoryEdit },
  	{ path: '/categories/list', component: CategoryList },
  ]
  ```	
  
- 实现CategoryList.vue的dom渲染 用的是之前Main.vue右侧的列表样式再从后台获取一下存储的列表数据重新渲染展示

	```js
	<template>
		<div class="about">
			<h1>分类列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="name" label="分类名称">
	      </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					 const res = await this.$http.get()
				}
			}
		}
	</script>
	```	
	
- 由于后端还没有写 所以现在再到后端路由里面去写这个请求分类列表页的接口 是在server端的routes/admin/index.js

	```js
	//获取分类
	router.get('/categories', async (req,res) => {
		const items = await Category.find().limit(10)
		res.send(items)
	})
	```	
	
- 写完以后 在前台发送请求 并通过created生命周期函数去触发方法
	```js
	async fetch(){
		const res = await this.$http.get("categories")
		this.items = res.data
	}
	```	
	
- 写完之后看通不通 记得要打开数据库 server端 admin端
> 通了的话 是会直接跳转到分类列表显示分类条数 然后对列表进行改删操作

### 3. 修改分类

- 在Element Ui官网找到table表格选项 给分类列表添加"编辑"按钮 

	```html
	<el-table-column
    fixed="right"
    label="操作"
    width="100">
    <template slot-scope="scope">
      <el-button type="text" size="small">编辑</el-button>
    </template>
 	</el-table-column>
	```	
	
- 给'<el-button>'编辑按钮添加点击跳转  通过scope.row._id 跳转当前的详情页 这个scope.row就相当于v-for循环的那个item ._id 就是当枪的那个id
	
	```html
	<el-button type="text" size="small" 
	        	@click="$router.push(`/categories/edit/${scope.row._id}`)">编辑</el-button>
	```	
	
- 跳转的详情页还没有进行页面渲染  去路由中指定跳转的页面 并接收id参数 props的意思是将url带过来的参数通过props进行接收

	```js
	{ path: '/categories/edit/:id', component: CategoryEdit, props: true },
	```	
	
- 在CategoryEdit.vue内 这个id就是经过路由设置 从url传递过来的id 和我们平常的$route.params.id是一个意思

	```js
	props:{
		id:{}
	},
	```	
	
- 如果CategoryEdit.vue内传入了这个id 那么就属于修改分类操作  这时h1标签需要根据是否传入id进行不同的操作显示

	```html
	<h1>{{id ? '编辑' : '新建'}}分类</h1>
	```		
	
- 如果CategoryEdit.vue内传入了这个id 则需要对分类信息进行修改操作 在打开这个页面后 需要从后台获取这个根据id存储的数据
- 获取这个数据有一个必要条件  就是要有了id之后才可以获取 而新建分类是没有id的 所以需要控制何时去获取 在有id的情况下才去获取后台的id数据

	```js
	created(){
		this.id && this.fetch()
	},
	```	
	
- this.fetch() 是从后台获取数据的方法  这个接口后台还没有写
- 需要在server/routes/admin/index.js路由中写这个接口请求 这个请求根据:id传进来一个id值 后台根据这个id去数据库里查找

	```js
	//获取分类详情
	router.get('/categories/:id', async (req,res) => {
		const model = await Category.findById(req.params.id)
		res.send(model)
	})
	```	
	
- 前台完善这个this.fetch()方法请求 

	```js
	async fetch(){
		const res = await this.$http.get(`categories/${this.id}`)
 		this.model = res.data
	}
	```	

- 这样在获取了要修改的数据保存的时候 与之前的seve()方法逻辑发生冲突 之前的逻辑是新增数据 而现在是更改数据 所以也需要加判断条件
- 判断的思路是这样的 如果当前页面有id 说明是更改数据那就查找数据  如果没有id那就是新增数据直接提交数据即可

	```js
	async save(){
		let res
    if (this.id) {
      res = await this.$http.put(`categories/${this.id}`, this.model)
    } else {
      res = await this.$http.post('categories', this.model)
    }
    this.$router.push('/categories/list')
		this.$message({
      type: 'success',
      message: '保存成功'
    })
	}
	```		 
	
- 后端server/routes/admin/index.js路由跟着去写一个put方法 用来完成更该数据的请求	

	```js
	//更改分类
	router.put('/categories/:id', async (req, res) => {
    const model = await Category.findByIdAndUpdate(req.params.id, req.body)
    res.send(model)
  })
	```	
	
- 写完之后看通不通 记得要打开数据库 server端 admin端		
 
### 4. 删除分类

- 在	CategoryList.vue 页面的<el-table-column>内添加一个'<el-button>'删除按钮 绑定的是remove事件 传入的当前项 就是v-for的那个item
	```html
	<el-button type="text" size="small" 
	        	@click="remove(scope.row)">删除</el-button>
  })
	```
	
- 在mothods中实现remove()方法删除数据时 需要添加一个Message Box拦截提示框 防止误操作删除 如果确定删除 请求后台接口删除指定数据
- 如果Message Box拦截提示框不加.catch() 我这里的控制台会报cancel警告  加上好看一些 最后重新加载分类列表数据 更新栏目
	```js
	async remove(row){
    this.$confirm(`是否确定要删除分类 "${row.name}"`, "提示", {
      confirmButtonText: "确定",
      cancelButtonText: "取消",
      type: "warning"
    }).then(async () => {
    	//请求的删除接口
      const res = await this.$http.delete(`categories/${row._id}`);
      this.$message({
        type: "success",
        message: "删除成功!"
      })
      this.fetch()
    }).catch(() => {
      this.$message({
        type: 'info',
        message: '已取消删除'
      });          
    })
	}
	```
	
- 后端server/routes/admin/index.js路由跟着去写一个delete方法  用来删除前台发送需要删除的id数据
	```js
	//删除分类
	router.delete('/categories/:id', async (req, res) => {
    await Category.findByIdAndDelete(req.params.id)
    res.send({
    	success:true
    })
  })
  ```
  
- 写完之后看通不通 记得要打开数据库 server端 admin端		
	
### 4. 子分类

- 刚才创建的都是一级分类  在一级分类下面还有二级分类甚至三级分类等子分类  关系上和父子组件类似
> 分类的关系主要体现在数据库中 在mongodb数据中 需要通过._id 进行相互关联  
> 对于mongodb的数据关联操作 可以看全栈之巅老师的mongodb关联教程  https://www.bilibili.com/video/av50037680
- 实现CategoryEdit.vue中创建分类时添加上级分类  通过v-for循环循环到<el-select>中   绑定的是model.parent label是展示的数据 value是存储的数据  
- 因为mongodb中相互的关联都是通过_id关联的  所以这里value存储的是_id 这样在选中后 选中的就是当前一级分类的的 _id  而不是名称 

	```html
	<!--上级分类-->
	<el-form-item label="上级分类">
    <el-select v-model="model.parent">
      <el-option v-for="item in parents" :key="item._id"
      :label="item.name" :value="item._id"></el-option>
    </el-select>
  </el-form-item>
  ```
  
- 上级分类就是我们添加的分类列表中的所有分类 需要在data中设置一个属性parents接收 然后从后台获取这些数据

	```js
	parents: []
	
	created(){
		this.fetchParents()
	}
	
	//获取上级分类
	async fetchParents(){
    const res = await this.$http.get('categories')
    this.parents = res.data
  }
  ```
  
- 由于前台提交创建分类的数据时多了一个parents字段 这个字段需要设置关联  在models/Category.js中需要添加一个父级分类的模型
- 这个parent规则的类型是一个._id 属性 关联的规则是Category模型 可以通过Category去找到这个ObjectId字段
- 这个关联不懂的可以去看全栈之巅老师的mongodb关联教程  https://www.bilibili.com/video/av50037680

 	```js
	parent: { type: mongoose.SchemaTypes.ObjectId, ref: 'Category' },
  ```
  
- 写完之后看通不通 记得要打开数据库 server端 admin端		

#### 在CategoryList.vue添加上级分类字段 展示当前分类隶属的上级分类 

	```html
	<el-table-column prop="parent.name" label="上级分类">
      </el-table-column>
  ```
  
- 但展示出来的._id是存储的id 就好像一堆数字代码  需要通过后台转义为字符类型的数据方便查看
- populate() 表示关联 取出  意思就是如果字段里有关联字段 取出这个数据 这里取出的是'parent'字段

	```js
	//获取分类
	router.get('/categories', async (req,res) => {
		const items = await Category.find().populate('parent').limit(10)
		res.send(items)
	})
  ```
  
- 写完之后看通不通 记得要打开数据库 server端 admin端		 

### 5.通用 CRUD 接口 

- 设计一个通用的CRUD接口 用来处理多接口的通用请求 
> 由于一个基本的项目后台涉及的增删改查都是类似相同的操作
> 所以我们在设计后台接口时 可以将其设计为一个通用的接口 将对后台的请求路径作为参数 比如.get('rest/:hero') 将这个hero设置为:id
> 在后台接收这个参数时 格式为 app.use('/admin/api/rest/:resoruce',router)
> 根据传入的/:id(这里是'resoruce') 这是我们传入的请求路径 同时这个:id也是mongodb集合的集合名  实现请求路径与集合名分别对应  但大小写和复数形式要改一下
> 'inflection'是用来加工字符的 这个请求路径通过('inflection').classify的加工后 变成首字母大写加负数的格式 这个格式的名字就是mongodb的集合名 
> 通过这个加工后的路径名名与mongodb建立链接 路径名直接就是mongodb的集合名 只要有集合无论是多少路径都可以进行通用的CRUD操作

- 给router添加参数 mergeParams: true 合并url参数  要不router获取不到app.use()上的参数id
> 在后台的接口都需要添加rest/ rest后面跟着的就是:id
- 以更改获取列表数据为例 这里只是改了一个做演示 需要通过**中间件**在app.use()中进行批量修改
> 说一下处理流程  这也是一个req,res的处理方法  
> 通过req.params.resource获取到通过参数传递过来的:id 
> 然后通过inflection.classify()将传递过来的:id改为首字母大写去掉复数的方式
> 引人这个加工后的参数mongodb模型
> 通过.find()查找所有  通过populate('parent')查找关联项 通过.limit(10)限制查找10条 将这个数据返回
> 里面最主要的就是将这个请求的参数获取到 然后引入相应的mongodb模型
- 例子在下面

	```js
	//获取分类
	router.get('/', async (req,res) => {
		const modelName = require('inflection').classify(req.params.resource)
		const Model = require(`../../models/${modelName}`)
		const items = await Category.find().populate('parent').limit(10)
		res.send(items)
	})
  ```
  
- 给app.use()添加中间件 添加在app.use()里就是全部添加过滤的意思 上面的就是一个举例

	```js
	//获取分类
	app.use('/admin/api/rest/:resource', async (req, res, next) => {
		const modelName = require('inflection').classify(req.params.resource)
		//给请求对象上挂载一个属性Model
		req.Model = require(`../../models/${modelName}`)
		next()
	},router)
  ```
  
- 更改router.get()接口中需要获取父类请求的操作 改为当有Category接口时 才查询父类返回

	```js
	//获取分类
	router.get('/', async (req,res) => {
		const queryOptions = {}
    if (req.Model.modelName === 'Category') {
      queryOptions.populate = 'parent'
    }
    const items = await req.Model.find().setOptions(queryOptions).limit(100)
    res.send(items)
	})
	```
  
- 将routes/admin/index.js中的请求进行整改

	```js
	module.exports = app => {
		//引入express使用它的子路由Router()	
		const express = require('express')
		const router = express.Router({
	    mergeParams: true
	  })	
		
		//创建分类
		router.post('/', async (req,res) => {
			const model = await req.Model.create(req.body)
			res.send(model)
		})
		
		//更改分类
		router.put('/:id', async (req, res) => {
	    const model = await req.Model.findByIdAndUpdate(req.params.id, req.body)
	    res.send(model)
	  })
		
		//删除分类
		router.delete('/:id', async (req, res) => {
	    await req.Model.findByIdAndDelete(req.params.id)
	    res.send({
	    	success:true
	    })
	  })
		
		//获取分类
		router.get('/', async (req,res) => {
			const queryOptions = {}
	    if (req.Model.modelName === 'Category') {
	      queryOptions.populate = 'parent'
	    }
	    const items = await req.Model.find().setOptions(queryOptions).limit(100)
	    res.send(items)
		})
		
		//获取分类详情
		router.get('/:id', async (req,res) => {
			const model = await req.Model.findById(req.params.id)
			res.send(model)
		})
		
		app.use('/admin/api/rest/:resource', async (req, res, next) => {
			const modelName = require('inflection').classify(req.params.resource)
			//给请求对象上挂载一个属性Model
			req.Model = require(`../../models/${modelName}`)
			next()
		},router)
	}
  ```
  
- 写完之后看通不通 记得要打开数据库 server端 admin端		

### 6.装备管理

- 对装备物品进行单独的管理  当某个英雄需要对应的物品时 引用这些物品的id关联到英雄的属性中即可
- 在Main.vue中创建物品列表 创建

	```html
	<el-menu-item-group>
    <template slot="title">物品</template>
    <el-menu-item index="/items/create">新建物品</el-menu-item>
    <el-menu-item index="/items/list">物品列表</el-menu-item>
  </el-menu-item-group>
	})
	```
	
- 创建	ItemEdit.vue 物品添加更改页面
	```html
	<template>
		<div class="about">
			<h1>{{id ? '编辑' : '新建'}}物品</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<el-form-item label="名称">
			    <el-input v-model="model.name"></el-input>
			  </el-form-item>
			  <el-form-item label="图标">
			    <el-input v-model="model.icon"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			props:{
				id:{}
			},
			data(){
				return {
					model: {}
				}
			},
			created(){
				this.id && this.fetch()
			},
			methods:{
				//点击提交按钮
				async save(){
					let res
		      if (this.id) {
		        res = await this.$http.put(`rest/items/${this.id}`, this.model)
		      } else {
		        res = await this.$http.post('rest/items', this.model)
		      }
		      this.$router.push('/items/list')
					this.$message({
		        type: 'success',
		        message: '保存成功'
		      })
				},
				//获取列表数据
				async fetch(){
					const res = await this.$http.get(`rest/items/${this.id}`)
	     		this.model = res.data
				},
			},
		}
	</script>
	```
	
- 在router中配置items路由

	```js
	import ItemEdit from './views/ItemEdit.vue'
	import ItemList from './views/ItemList.vue'
	
	{ path: '/items/create', component: ItemEdit },
	{ path: '/items/edit/:id', component: ItemEdit, props: true },
  { path: '/items/list', component: ItemList },
	```
	
- 在后台models中创建Item.js模型 保存上传的物品数据

	```js
	//保存物品 
	const mongoose = require('mongoose')
	
	const schema = new mongoose.Schema({
	  name: { type: String },
	  icon: { type: String },
	})
	
	module.exports = mongoose.model('Item', schema)
	```
	
- 创建	ItemList.vue  物品展示列表

	```html
	<template>
		<div class="about">
			<h1>物品列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="name" label="物品名称">
	      </el-table-column>
	      <el-table-column
		      fixed="right"
		      label="操作"
		      width="180">
		      <template slot-scope="scope">
		        <el-button type="text" size="small" 
		        	@click="$router.push(`/items/edit/${scope.row._id}`)">编辑</el-button>
		        <el-button type="text" size="small" 
		        	@click="remove(scope.row)">删除</el-button>
		      </template>
		    </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					const res = await this.$http.get("rest/items")
					this.items = res.data
				},
				async remove(row){
		      this.$confirm(`是否确定要删除分类 "${row.name}"`, "提示", {
		        confirmButtonText: "确定",
		        cancelButtonText: "取消",
		        type: "warning"
		      }).then(async () => {
		      	//请求的删除接口
		        const res = await this.$http.delete(`rest/items/${row._id}`);
		        this.$message({
		          type: "success",
		          message: "删除成功!"
		        })
		        this.fetch()
		      }).catch(() => {
	          this.$message({
	            type: 'info',
	            message: '已取消删除'
	          });          
	        })
		      
				}
			}
		}
	</script>
	```	
	
### 7.图片上传 (multer)

- 物品更新需要上传图片 在Element Ui中有上传组件'<el-upload>' Upload上传
- 他有几个关键的属性  :action 表示上传的路径地址 :on-success上传之后的返回方法 显示图片是里面的img标签 

	```html
	<el-upload
	  class="avatar-uploader"
	  :action="$http.defaults.baseURL+'/upload'"
	  :show-file-list="false"
	  :on-success="afterUpload">
	  <img v-if="model.icon" :src="model.icon" class="avatar">
	  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
	</el-upload>
	```
	
- 上传图片的css部分  这部分控制着上传的图片样式大小

	```css
	.avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409EFF;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .avatar {
    width: 178px;
    height: 178px;
    display: block;
  }	
	```
	
- 设置图片上传之后的方法	:on-success="afterUpload"

	```js
	//图片上传之后
	afterUpload(res){
		console.log(res)
	}
	```
	
- 图片的上传地址为http://localhost:3000/admin/api/upload 后台还没有相应的接口处理 需要添加一个处理图片上传的请求
> 但express获取不到上传图片的数据 需要一个中间件专门处理上传数据 multer
- multer的用法为接收到上传的数据 并通过目标地址dest方法将其存放在某个文件中 项目中这个存放的文件为 uploads
- upload.single('file') 表示单文件的上传  字段名是'file'

	```js
	//处理图片上传请求
	const multer = require('multer')
  const upload = multer({ dest: __dirname + '/../../uploads' })
	app.post('/admin/api/upload', upload.single('file'), async (req, res) => {
		//获取图片上传的信息  添加一个url返回去
    const file = req.file
    file.url = `http://localhost:3000/uploads/${file.filename}`
    res.send(file)
  })
	```
	
- 需要将上传的文件夹设置为静态文件托管 这样前台才能访问到这个文件夹里面的内容  这个修改地址是 server/index.js

	```js
	//开放静态资源目录 
	app.use('/uploads', express.static(__dirname + '/uploads'))
	```
	
- 在前台上传图片之后  需要将图片地址给前台 这样前台在上传完成后也会展示这张图片 

	```js
	//图片上传之后
	afterUpload(res){
		this.model.icon = res.url
	}
	```
	
- 虽然修改了model.icon 但由于vue数据响应式的问题 就是给一个空对象的某个属性赋值会赋不上  这样会有两层 第一层是创建这个属性 第二层是给这个属性赋值
- 解决的办法有两个 一个是给空对象设默认值  另一个是通过this.$set()显示赋值

	```js
	model: {
		name:'',
		icon:''
	}
				
	this.$set(this.model, 'icon', res.url)
	```

- 写完之后看通不通 记得要打开数据库 server端 admin端	
	
- 在ItemList.vue 列表中展示物品列表  并增加图标按钮  这个icon就是创建修改页面的那个通过特殊方法赋值的icon

	```html
	<el-table-column prop="icon" label="图标">
  	<template slot-scope="scope">
  		<img :src="scope.row.icon" alt="" style="height:3rem;" />
  	</template>	
  </el-table-column>
	```
	
### 8.英雄管理  
	
- 在Main.vue 中添加英雄管理的列表

	```html
	<el-menu-item-group>
    <template slot="title">英雄</template>
    <el-menu-item index="/heroes/create">新建英雄</el-menu-item>
    <el-menu-item index="/heroes/list">英雄列表</el-menu-item>
  </el-menu-item-group>
	```
	
- 在router路由中配置路由

	```js
	import HeroEdit from './views/HeroEdit.vue'
	import HeroList from './views/HeroList.vue'
	
	{ path: '/heroes/create', component: HeroEdit },
  { path: '/heroes/edit/:id', component: HeroEdit, props: true },
  { path: '/heroes/list', component: HeroList },
	```
	
- 创建HeroEdit.vue 展示基本的英雄添加页面

	```html
	<template>
		<div class="about">
			<h1>{{id ? '编辑' : '新建'}}英雄</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<el-form-item label="名称">
			    <el-input v-model="model.name"></el-input>
			  </el-form-item>
			  <el-form-item label="头像">
			    <el-upload
					  class="avatar-uploader"
					  :action="$http.defaults.baseURL+'/upload'"
					  :show-file-list="false"
					  :on-success="afterUpload">
					  <img v-if="model.avatar" :src="model.vatar" class="avatar">
					  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
					</el-upload>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			props:{
				id:{}
			},
			data(){
				return {
					model: {
						name:'',
						avatar:''
					}
				}
			},
			created(){
				this.id && this.fetch()
			},
			methods:{
				//点击提交按钮
				async save(){
					let res
		      if (this.id) {
		        res = await this.$http.put(`rest/heroes/${this.id}`, this.model)
		      } else {
		        res = await this.$http.post('rest/heroes', this.model)
		      }
		      this.$router.push('/heroes/list')
					this.$message({
		        type: 'success',
		        message: '保存成功'
		      })
				},
				//获取列表数据
				async fetch(){
					const res = await this.$http.get(`rest/heroes/${this.id}`)
	     		this.model = res.data
				},
				//图片上传之后
				afterUpload(res){
					this.model.avatar = res.url
				}
			},
		}
	</script>
	
	<style>
	  .avatar-uploader .el-upload {
	    border: 1px dashed #d9d9d9;
	    border-radius: 6px;
	    cursor: pointer;
	    position: relative;
	    overflow: hidden;
	  }
	  .avatar-uploader .el-upload:hover {
	    border-color: #409EFF;
	  }
	  .avatar-uploader-icon {
	    font-size: 28px;
	    color: #8c939d;
	    width: 178px;
	    height: 178px;
	    line-height: 178px;
	    text-align: center;
	  }
	  .avatar {
	    width: 178px;
	    height: 178px;
	    display: block;
	  }	
	</style>
	```
	
- 由于HeroEdit.vue 页面有英雄数据上传功能 所以要创建集合模型 保存英雄数据 models/Hero.js

	```js
	//保存英雄 
	const mongoose = require('mongoose')
	
	const schema = new mongoose.Schema({
	  name: { type: String },
	  avatar: { type: String },
	})
	
	module.exports = mongoose.model('Hero', schema)
	```
	
- 写完之后看通不通 记得要打开数据库 server端 admin端	

### 9.编辑英雄 (关联,多选,el-select, multiple)

- 在英雄的集合模型上添加英雄的其他属性 比如关联分类 技能 出装 团战思路等  修改models/Hero.js 要注意的是存储多个对象的话一般用数组

	```js
	//保存英雄 
	const mongoose = require('mongoose')

	const schema = new mongoose.Schema({
	  name: { type: String },
	  avatar: { type: String },
	  title: { type: String },
	  categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category' }],
	  scores: {
	    difficult: { type: Number },
	    skills: { type: Number },
	    attack: { type: Number },
	    survive: { type: Number },
	  },
	  skills: [{
	    icon: { type: String },
	    name: { type: String },
	    description: { type: String },
	    tips: { type: String },
	  }],
	  items1: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Item' }],
	  items2: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Item' }],
	  usageTips: { type: String },
	  battleTips: { type: String },
	  teamTips: { type: String },
	  partners: [{
	    hero: { type: mongoose.SchemaTypes.ObjectId, ref: 'Hero' },
	    description: { type: String },
	  }],
	})
	
	module.exports = mongoose.model('Hero', schema)
	```
	
- 修改HeroEdit.vue 文件  添加 "称号" "类型"

	```html
	<el-form-item label="称号">
    <el-input v-model="model.title"></el-input>
  </el-form-item>
  <el-form-item label="类型">
    <el-select v-model="model.categories" multiple>
      <el-option
        v-for="item of categories"
        :key="item._id"
        :label="item.name"
        :value="item._id"
      ></el-option>
    </el-select>
  </el-form-item>
	```
	
- 通过请求后台数据  将'<el-select>'标签类型中的数据渲染出来 这个类型就是分类 记得在data中定义categories接收数据的数组

	```html
	//请求类型
	async fetchCategories() {
    const res = await this.$http.get(`rest/categories`);
    this.categories = res.data;
  },
	```
	
- 添加英雄操作 '难度' '技能' '攻击' '生存'  用的是'<el-rate>'标签 顺便定一下位置

	```html
	<el-form-item label="难度">
    <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.difficult"></el-rate>
  </el-form-item>
  <el-form-item label="技能">
    <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.skills"></el-rate>
  </el-form-item>
  <el-form-item label="攻击">
    <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.attack"></el-rate>
  </el-form-item>
  <el-form-item label="生存">
    <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.survive"></el-rate>
  </el-form-item>
	```

- 由于不给model设置scores属性 直接访问scores中的属性会报错  需要给model添加一个默认的scores属性

	```html
	model: {
		name:'',
		avatar:'',
		scores: {
      difficult: 0
    }
	},
	```
	
- 由于model设置scores属性是前台设置  后台返回数据并没有scores字段 通过this.xxx=赋值会覆盖scores属性 需要通过Object.assing{}

	```js
	async fetch() {
    const res = await this.$http.get(`rest/heroes/${this.id}`);
    this.model = Object.assign({}, this.model, res.data);
  },
	```

- 添加顺风和逆风出装 html区块 选择的数据保存到 'items1' 'items2' 这两个数据就是Hero.js集合模型中定义的那两个

	```html
	<el-form-item label="顺风出装">
    <el-select v-model="model.items1" multiple>
      <el-option v-for="item of items" :key="item._id" :label="item.name" :value="item._id"></el-option>
    </el-select>
  </el-form-item>
  <el-form-item label="逆风出装">
    <el-select v-model="model.items2" multiple>
      <el-option v-for="item of items" :key="item._id" :label="item.name" :value="item._id"></el-option>
    </el-select>
  </el-form-item>
	```

- 这里需要循环装备数据items  要在data中定义一个空数组items 然后通过方法从后台获取所有的装备数据  记得在created周期中触发方法

	```js
	items: [],
	
	async fetchItems() {
    const res = await this.$http.get(`rest/items`);
    this.items = res.data;
  }
	```
	
- 添加 '使用技巧' '对抗技巧' '团战思路'  先添加html代码 

	```html
	<el-form-item label="使用技巧">
    <el-input type="textarea" v-model="model.usageTips"></el-input>
  </el-form-item>
  <el-form-item label="对抗技巧">
    <el-input type="textarea" v-model="model.battleTips"></el-input>
  </el-form-item>
  <el-form-item label="团战思路">
    <el-input type="textarea" v-model="model.teamTips"></el-input>
  </el-form-item>
	```

- 在HeroList.vue 英雄列表页面  显示英雄称号 

	```html
	<el-table-column prop="title" label="英雄称号">
  </el-table-column>
	```

### 10.技能编辑

- 给英雄添加技能信息  需要通过'<el-tabs>'进行分块处理 因为第一页的数据过多 需要进行分页处理  样式和tab切换类似
- 第一页基本信息的html

	```html
	<el-tab-pane label="基本信息" name="basic">
		<el-form-item label="名称">
	    <el-input v-model="model.name"></el-input>
	  </el-form-item>
		<el-form-item label="称号">
	    <el-input v-model="model.title"></el-input>
	  </el-form-item>
	  <el-form-item label="头像">
	    <el-upload
			  class="avatar-uploader"
			  :action="$http.defaults.baseURL+'/upload'"
			  :show-file-list="false"
			  :on-success="afterUpload">
			  <img v-if="model.avatar" :src="model.avatar" class="avatar">
			  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
			</el-upload>
	  </el-form-item>
	  <el-form-item label="类型">
	    <el-select v-model="model.categories" multiple>
        <el-option
          v-for="item of categories"
          :key="item._id"
          :label="item.name"
          :value="item._id"
        ></el-option>
      </el-select>
	  </el-form-item>
	  
	  <el-form-item label="难度">
      <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.difficult"></el-rate>
    </el-form-item>
    <el-form-item label="技能">
      <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.skills"></el-rate>
    </el-form-item>
    <el-form-item label="攻击">
      <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.attack"></el-rate>
    </el-form-item>
    <el-form-item label="生存">
      <el-rate style="margin-top:0.6rem" :max="9" show-score v-model="model.scores.survive"></el-rate>
    </el-form-item>
        
	  <el-form-item label="顺风出装">
      <el-select v-model="model.items1" multiple>
        <el-option v-for="item of items" :key="item._id" :label="item.name" :value="item._id"></el-option>
      </el-select>
    </el-form-item>
    <el-form-item label="逆风出装">
      <el-select v-model="model.items2" multiple>
        <el-option v-for="item of items" :key="item._id" :label="item.name" :value="item._id"></el-option>
      </el-select>
    </el-form-item>
	  
	  <el-form-item label="使用技巧">
      <el-input type="textarea" v-model="model.usageTips"></el-input>
    </el-form-item>
    <el-form-item label="对抗技巧">
      <el-input type="textarea" v-model="model.battleTips"></el-input>
    </el-form-item>
    <el-form-item label="团战思路">
      <el-input type="textarea" v-model="model.teamTips"></el-input>
    </el-form-item>
	</el-tab-pane>
	```

- 第二页是添加技能 通过button添加按钮点击后  给model.skills添加一个空对象  由于循环的是model.skills 所以点击会不断添加空对象
> 在每个单项的删除按钮点击后 通过splice方法在直接删除model.skills数组当前项的对象  也不用去 methods中定义方法执行了
- 图标在上传之后后台会返回图标的地址让你显示出来  一般写在methods中 这里用到了 $set() 或者预定义一个空的model.skills

	```html
	<el-tab-pane label="技能" name="skills">
		<el-button size="small" @click="model.skills.push({})">
      <i class="el-icon-plus"></i> 添加技能
    </el-button>
    <el-row type="flex" style="flex-wrap: wrap">
      <el-col :md="12" v-for="(item, i) in model.skills" :key="i">
        <el-form-item label="名称">
          <el-input v-model="item.name"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-upload
            class="avatar-uploader"
            :action="$http.defaults.baseURL + '/upload'"
            :show-file-list="false"
            :on-success="res => $set(item, 'icon', res.url)"
          >
            <img v-if="item.icon" :src="item.icon" class="avatar">
            <i v-else class="el-icon-plus avatar-uploader-icon"></i>
          </el-upload>
        </el-form-item>
        <el-form-item label="描述">
          <el-input v-model="item.description" type="textarea"></el-input>
        </el-form-item>
        <el-form-item label="小提示">
          <el-input v-model="item.tips" type="textarea"></el-input>
        </el-form-item>
        <el-form-item>
          <el-button size="small" type="danger" 
          @click="model.skills.splice(i, 1)"
          >删除</el-button>
        </el-form-item>
      </el-col>
    </el-row>
	</el-tab-pane>
	```
	
- 图标图片是178px有点大   将style中的图片大小改为	5rem 

	```css
	.avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 5rem;
    height: 5rem;
    line-height: 5rem;
    text-align: center;
  }
  .avatar {
    width: 5rem;
    height: 5rem;
    display: block;
  }	
	```
	
- 写完之后看通不通 记得要打开数据库 server端 admin端	

### 11.文章管理

- 在Main.vue中添加文章管理html代码

	```js
	<el-menu-item-group>
    <template slot="title">文章</template>
    <el-menu-item index="/articles/create">新建文章</el-menu-item>
    <el-menu-item index="/articles/list">文章列表</el-menu-item>
  </el-menu-item-group>
	```	

#### 创建 ArticleEdit.vue ArticleList.vue 页面  复制的是分类页面的列表和编辑页

- 有一点需要注意 文章可能所属多个分类 

- 在router中配置路由

	```js
	import ArticleEdit from './views/ArticleEdit.vue'
	import ArticleList from './views/ArticleList.vue'
	
	{ path: '/articles/create', component: ArticleEdit },
  { path: '/articles/edit/:id', component: ArticleEdit, props: true },
  { path: '/articles/list', component: ArticleList },
  }
	```	
	
- 创建	ArticleEdit.vue页面 注意从后台获取的数据是categories  data中定义的也是categories 而其他请求的接口是articles

	```html
	<template>
		<div class="about">
			<h1>{{id ? '编辑' : '新建'}}文章</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<!--上级分类-->
				<el-form-item label="所属分类">
	        <el-select v-model="model.categories" multiple>
	          <el-option v-for="item in categories" :key="item._id"
	          :label="item.name" :value="item._id"></el-option>
	        </el-select>
	      </el-form-item>
				<el-form-item label="标题">
			    <el-input v-model="model.title"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			props:{
				id:{}
			},
			data(){
				return {
					model: {},
					categories: []
				}
			},
			created(){
				this.id && this.fetch()
				this.fetchCatgories()
			},
			methods:{
				//点击提交按钮
				async save(){
					let res
		      if (this.id) {
		        res = await this.$http.put(`rest/articles/${this.id}`, this.model)
		      } else {
		        res = await this.$http.post('rest/articles', this.model)
		      }
		      this.$router.push('/articles/list')
					this.$message({
		        type: 'success',
		        message: '保存成功'
		      })
				},
				//获取列表数据
				async fetch(){
					const res = await this.$http.get(`rest/articles/${this.id}`)
	     		this.model = res.data
				},
				//获取上级分类
				async fetchCatgories(){
		      const res = await this.$http.get('rest/categories')
		      this.categories = res.data
		    },
			},
		}
	</script>
	```	

- 后台需要在models中创建模型用来存储文章的数据 创建 Article.js 三个属性:'关联分类' '标题' '详情' 详情body是后来讲的 现在都写上省事

	```js
	const mongoose = require('mongoose')

	const schema = new mongoose.Schema({
	  categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: 'Category' }],
	  title: { type: String },
	  body: { type: String },
	}, {
	  timestamps: true
	})
	
	module.exports = mongoose.model('Article', schema)
	```
		
- 完成ArticleList.vue的页面布局

	```html
	<template>
		<div class="about">
			<h1>文章列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="title" label="标题">
	      </el-table-column>
	      <el-table-column
		      fixed="right"
		      label="操作"
		      width="180">
		      <template slot-scope="scope">
		        <el-button type="text" size="small" 
		        	@click="$router.push(`/articles/edit/${scope.row._id}`)">编辑</el-button>
		        <el-button type="text" size="small" 
		        	@click="remove(scope.row)">删除</el-button>
		      </template>
		    </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					const res = await this.$http.get("rest/articles")
					this.items = res.data
				},
				async remove(row){
		      this.$confirm(`是否确定要删除文章 "${row.title}"`, "提示", {
		        confirmButtonText: "确定",
		        cancelButtonText: "取消",
		        type: "warning"
		      }).then(async () => {
		      	//请求的删除接口
		        const res = await this.$http.delete(`rest/articles/${row._id}`);
		        this.$message({
		          type: "success",
		          message: "删除成功!"
		        })
		        this.fetch()
		      }).catch(() => {
	          this.$message({
	            type: 'info',
	            message: '已取消删除'
	          });          
	        })
		      
				}
			}
		}
	</script>
	```
	
- 写完之后看通不通 记得要打开数据库 server端 admin端	

### 12.富文本编辑器 (quill)

- 之前写了基本的界面只包含分类和标题 同时要添加文章详情 一般需要用到富文本编辑器 vue-editor quill 这里用的是vue2-editor插件
> 在后台管理admin文件下安装  vue2-editor 不要安装到server文件下 
- 在文章编辑页面 ArticleEdit.vue引入 vue2-editor并使用 使用的方式和使用组件一个方式

	```js
	import { VueEditor } from "vue2-editor"
	
	components: {
    VueEditor
  },
	```
	
- 页面的文章详情区域会改为如下代码 两个方法均为处理图片上传的方法 要写在methods中 这个图片的接口和之前上传头像技能的接口是同一个 所以写的file
	
	```html
	<el-form-item label="详情">
    <vue-editor v-model="model.body" useCustomImageHandler @imageAdded="handleImageAdded"></vue-editor>
  </el-form-item>
 
	//处理图片上传
  async handleImageAdded(file, Editor, cursorLocation, resetUploader) {
    const formData = new FormData();
    formData.append("file", file);
    const res = await this.$http.post("upload", formData);
    Editor.insertEmbed(cursorLocation, "image", res.data.url);
    resetUploader();
  },
	```
	
- 写完之后看通不通 记得要打开数据库 server端 admin端	

### 13.首页广告管理

- 在Main.vue中添加广告区域的html

	```html
	<!--广告位列表-->
  <el-menu-item-group>
    <template slot="title">广告位</template>
    <el-menu-item index="/ads/create">新建广告位</el-menu-item>
    <el-menu-item index="/ads/list">广告位列表</el-menu-item>
  </el-menu-item-group>
	```
	
- 创建  AdEdit.vue AdList.vue 两个页面

- 在router中配置路由

	```js
	import AdEdit from './views/AdEdit.vue'
	import AdList from './views/AdList.vue'
	
	{ path: '/ads/create', component: AdEdit },
  { path: '/ads/edit/:id', component: AdEdit, props: true },
  { path: '/ads/list', component: AdList },
	```
	
- 在后台models中创建模型 Ad.js 用来存储广告的数据

	```js
	const mongoose = require('mongoose')
	
	const schema = new mongoose.Schema({
	  name: { type: String },
	  items: [{
	  image: { type: String },
	  url: { type: String },
	  }]
	})
	
	module.exports = mongoose.model('Ad', schema)
	```

- 完善 AdEdit.vue页面

	```html
	<template>
		<div class="about">
			<h1>{{id ? '编辑' : '新建'}}广告位</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<el-form-item label="名称">
			    <el-input v-model="model.name"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			props:{
				id:{}
			},
			data(){
				return {
					model: {}
				}
			},
			created(){
				this.id && this.fetch()
			},
			methods:{
				//点击提交按钮
				async save(){
					let res
		      if (this.id) {
		        res = await this.$http.put(`rest/ads/${this.id}`, this.model)
		      } else {
		        res = await this.$http.post('rest/ads', this.model)
		      }
		      this.$router.push('/ads/list')
					this.$message({
		        type: 'success',
		        message: '保存成功'
		      })
				},
				//获取列表数据
				async fetch(){
					const res = await this.$http.get(`rest/ads/${this.id}`)
	     		this.model = res.data
				},
			},
		}
	</script>
	
	```	

- 完善	AdList.vue 页面

	```html
	<template>
		<div class="about">
			<h1>广告位列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="name" label="广告名称">
	      </el-table-column>
	      <el-table-column
		      fixed="right"
		      label="操作"
		      width="180">
		      <template slot-scope="scope">
		        <el-button type="text" size="small" 
		        	@click="$router.push(`/ads/edit/${scope.row._id}`)">编辑</el-button>
		        <el-button type="text" size="small" 
		        	@click="remove(scope.row)">删除</el-button>
		      </template>
		    </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					const res = await this.$http.get("rest/ads")
					this.items = res.data
				},
				async remove(row){
		      this.$confirm(`是否确定要删除分类 "${row.name}"`, "提示", {
		        confirmButtonText: "确定",
		        cancelButtonText: "取消",
		        type: "warning"
		      }).then(async () => {
		      	//请求的删除接口
		        const res = await this.$http.delete(`rest/ads/${row._id}`);
		        this.$message({
		          type: "success",
		          message: "删除成功!"
		        })
		        this.fetch()
		      }).catch(() => {
	          this.$message({
	            type: 'info',
	            message: '已取消删除'
	          });          
	        })
		      
				}
			}
		}
	</script>
	```
	
- 再次完善 AdEdit.vue页面 添加广告图片和url  

	```html
	<el-form-item label="广告">
    <el-button size="small" @click="model.items.push({})">
      <i class="el-icon-plus"></i> 添加广告
    </el-button>
    <el-row type="flex" style="flex-wrap: wrap">
      <el-col :md="24" v-for="(item, i) in model.items" :key="i">
        <el-form-item label="跳转链接 (URL)">
          <el-input v-model="item.url"></el-input>
        </el-form-item>
        <el-form-item label="图片" style="margin-top: 0.5rem;">
          <el-upload
            class="avatar-uploader"
            :action="$http.defaults.baseURL + '/upload'"
            :show-file-list="false"
            :on-success="res => $set(item, 'image', res.url)"
          >
            <img v-if="item.image" :src="item.image" class="avatar">
            <i v-else class="el-icon-plus avatar-uploader-icon"></i>
          </el-upload>
        </el-form-item>
        
        <el-form-item>
          <el-button size="small" type="danger" @click="model.items.splice(i, 1)">删除</el-button>
        </el-form-item>
      </el-col>
    </el-row>
  </el-form-item>
	```	

- 优化css样式 将其写成一个文件通过main.js引入  其他控制上传页面的css样式可以去掉了

	```js
	//引入css文件 
	import './style.css'
	```	
	
### 14.管理员账号管理 (bcrypt)

- 先在models上创建一个管理员模型 AdminUser.js 基本的模型为两个字段 用户名和密码

	```js
	const mongoose = require('mongoose')

	const schema = new mongoose.Schema({
	  username: { type: String },
	  password: {
	    type: String,
	  },
	})
	
	module.exports = mongoose.model('AdminUser', schema)
	```	
	
#### 在Main.vue中重新规划列表显示 并在运营管理中创建管理员列表  

	```html
	<el-container style="height: 100vh;">
	  <el-aside width="200px" style="background-color: rgb(238, 241, 246)">
	    <el-menu router :default-openeds="['1']" unique-opened :default-active="$route.path">
	      <el-submenu index="1">
	        <template slot="title"><i class="el-icon-message"></i>内容管理</template>
	        
	        <!--物品列表-->
	        <el-menu-item-group>
	          <template slot="title">物品</template>
	          <el-menu-item index="/items/create">新建物品</el-menu-item>
	          <el-menu-item index="/items/list">物品列表</el-menu-item>
	        </el-menu-item-group>
	        <!--英雄列表-->
	        <el-menu-item-group>
	          <template slot="title">英雄</template>
	          <el-menu-item index="/heroes/create">新建英雄</el-menu-item>
	          <el-menu-item index="/heroes/list">英雄列表</el-menu-item>
	        </el-menu-item-group>
	        <!--文章列表-->
	        <el-menu-item-group>
	          <template slot="title">文章</template>
	          <el-menu-item index="/articles/create">新建文章</el-menu-item>
	          <el-menu-item index="/articles/list">文章列表</el-menu-item>
	        </el-menu-item-group>
	        
	      </el-submenu>
	      <el-submenu index="2">
	        <template slot="title"><i class="el-icon-menu"></i>运营管理</template>
	        
	        <!--广告位列表-->
	        <el-menu-item-group>
	          <template slot="title">广告位</template>
	          <el-menu-item index="/ads/create">新建广告位</el-menu-item>
	          <el-menu-item index="/ads/list">广告位列表</el-menu-item>
	        </el-menu-item-group>
	        <el-menu-item-group title="分组2">
	          <el-menu-item index="2-3">选项3</el-menu-item>
	        </el-menu-item-group>
	        <el-submenu index="2-4">
	          <template slot="title">选项4</template>
	          <el-menu-item index="2-4-1">选项4-1</el-menu-item>
	        </el-submenu>
	      </el-submenu>
	      <el-submenu index="3">
	        <template slot="title"><i class="el-icon-setting"></i>系统设置</template>
	        <!--分类列表-->
	        <el-menu-item-group>
	          <template slot="title">分类</template>
	          <el-menu-item index="/categories/create">新建分类</el-menu-item>
	          <el-menu-item index="/categories/list">分类列表</el-menu-item>
	        </el-menu-item-group>
	        <!--管理员管理-->
	        <el-menu-item-group>
	          <template slot="title">管理员</template>
	          <el-menu-item index="/admin_users/create">新建管理员</el-menu-item>
	          <el-menu-item index="/admin_users/list">管理员列表</el-menu-item>
	        </el-menu-item-group>
	      </el-submenu>
	    </el-menu>
	  </el-aside>
	  
	  <el-container>
	    <el-header style="text-align: right; font-size: 12px">
	      <el-dropdown>
	        <i class="el-icon-setting" style="margin-right: 15px"></i>
	        <el-dropdown-menu slot="dropdown">
	          <el-dropdown-item>查看</el-dropdown-item>
	          <el-dropdown-item>新增</el-dropdown-item>
	          <el-dropdown-item>删除</el-dropdown-item>
	        </el-dropdown-menu>
	      </el-dropdown>
	      <span>王小虎</span>
	    </el-header>
	    
	    <el-main>
	    	<router-view></router-view>
	      <!--<el-table :data="tableData">
	        <el-table-column prop="date" label="日期" width="140">
	        </el-table-column>
	        <el-table-column prop="name" label="姓名" width="120">
	        </el-table-column>
	        <el-table-column prop="address" label="地址">
	        </el-table-column>
	      </el-table>-->
	    </el-main>
	  </el-container>
	</el-container>
	```	

- 创建 AdminUserEdit.vue  AdminUserList.vue  两个页面 

- 在router中配置路由 

	```js
	import AdminUserEdit from './views/AdminUserEdit.vue'
	import AdminUserList from './views/AdminUserList.vue'
	
	{ path: '/admin_users/create', component: AdminUserEdit },
  { path: '/admin_users/edit/:id', component: AdminUserEdit, props: true },
  { path: '/admin_users/list', component: AdminUserList },
	```	

- 基本的AdminUserEdit.vue页面搭建

	```html
	<template>
		<div class="about">
			<h1>{{id ? '编辑' : '新建'}}管理员</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				
				<el-form-item label="名称">
			    <el-input v-model="model.username"></el-input>
			  </el-form-item>
			  <el-form-item label="密码">
			    <el-input type="password" v-model="model.password"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			props:{
				id:{}
			},
			data(){
				return {
					model: {}
				}
			},
			created(){
				this.id && this.fetch()
			},
			methods:{
				//点击提交按钮
				async save(){
					let res
		      if (this.id) {
		        res = await this.$http.put(`rest/admin_users/${this.id}`, this.model)
		      } else {
		        res = await this.$http.post('rest/admin_users', this.model)
		      }
		      this.$router.push('/admin_users/list')
					this.$message({
		        type: 'success',
		        message: '保存成功'
		      })
				},
				//获取列表数据
				async fetch(){
					const res = await this.$http.get(`rest/admin_users/${this.id}`)
	     		this.model = res.data
				},
			},
		}
	</script>
	```	
	
- 基本的AdminUserList.vue 页面搭建

	```js
	<template>
		<div class="about">
			<h1>管理员列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="username" label="用户名">
	      </el-table-column>
	      <el-table-column
		      fixed="right"
		      label="操作"
		      width="180">
		      <template slot-scope="scope">
		        <el-button type="text" size="small" 
		        	@click="$router.push(`/admin_users/edit/${scope.row._id}`)">编辑</el-button>
		        <el-button type="text" size="small" 
		        	@click="remove(scope.row)">删除</el-button>
		      </template>
		    </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					const res = await this.$http.get("rest/admin_users")
					this.items = res.data
				},
				async remove(row){
		      this.$confirm(`是否确定要删除 "${row.username}"`, "提示", {
		        confirmButtonText: "确定",
		        cancelButtonText: "取消",
		        type: "warning"
		      }).then(async () => {
		      	//请求的删除接口
		        const res = await this.$http.delete(`rest/admin_users/${row._id}`);
		        this.$message({
		          type: "success",
		          message: "删除成功!"
		        })
		        this.fetch()
		      }).catch(() => {
	          this.$message({
	            type: 'info',
	            message: '已取消删除'
	          });          
	        })
		      
				}
			}
		}
	</script>
	```	

- 对数据库管理员集合模型进行散列加密bcrypt 先安装bcrypt插件 保证用户密码的安全性 修改后的AdminUser.js为 只散列一次+不显示密码

	```js
	const mongoose = require('mongoose')

	const schema = new mongoose.Schema({
	  username: { type: String },
	  password: {
	    type: String,
	    select: false,
	    set(val) {
	      return require('bcrypt').hashSync(val, 10)
	    }
	  },
	})
	
	module.exports = mongoose.model('AdminUser', schema)
	```	

### 15.登录页面

- 登录页面Login.vue 属于单独的一个路由组件 与之前Main.vue属于平级页面 

- 创建Login.vue 页面 用的是Element Ui中的卡片组件'<el-card>' 代码如下

	```html
	<template>
	  <div class="login-container">
	    <el-card header="请先登录" class="login-card">
	      <el-form @submit.native.prevent="login">
	        <el-form-item label="用户名">
	          <el-input v-model="model.username"></el-input>
	        </el-form-item>
	        <el-form-item label="密码">
	          <el-input type="password" v-model="model.password"></el-input>
	        </el-form-item>
	        <el-form-item>
	          <el-button type="primary" native-type="submit">登录</el-button>
	        </el-form-item>
	        
	      </el-form>
	    </el-card>
	  </div>
	</template>
	<script>
	export default {
	  data(){
	    return {
	      model: {
	      	username:''
	      	password:''
	      }
	    }
	  },
	  methods: {
	    async login(){
	      const res = await this.$http.post('login', this.model)
	       
	    }
	  }
	}
	</script>
	
	<style>
	.login-card{
	  width: 25rem;
	  margin: 5rem auto;
	}
	</style>
	```	

- 配置Login.vue路由

	```js
	import Login from './views/Login.vue'
	
	{ path: '/login', name: 'login', component: Login},
	```	

### 16.登录接口 (jwt,jsonwebtoken)

- 写后台login的登录接口 后台需要校验用户名和密码 返回给前台一个token 需要安装token  npm i jsonwebtoken  routes/admin/index.js
- token的作用和session类似  前台登陆后在一定时间内打开网页/app可以自动登录 因为在打开网页时会通过请求头向后台发送token/session 比对成功自动登录	
- 由于验证用户名和密码 还有验证token经常会返会错误提示 所以使用插件assert 前面验证用户名和密码和token的验证使用 assert处理 npm i http-assert 但他抛出的是错误异常   

	```js
	//引入token和AdminUser集合和assert报错
	const AdminUser = require('../../models/AdminUser')
	const jwt = require('jsonwebtoken')
	const assert = require('http-assert')
	
	//登录接口
	app.post('/admin/api/login', async (req, res) => {
    const { username, password } = req.body
    // 1.根据用户名找用户
    const user = await AdminUser.findOne({ username }).select('+password')
    assert(user, 422, '用户不存在')
    // 2.校验密码
    const isValid = require('bcrypt').compareSync(password, user.password)
    assert(isValid, 422, '密码错误')
    // 3.返回token
    const token = jwt.sign({ id: user._id }, app.get('secret'))
    res.send({ token })
  })
	```	
	
- 由于assert是直接抛出异常报错 并没有提示信息或者通过send()返回 在后台返回错误之前需要进行拦截 将错误处理成json格式的数据方便前台解读

	```js
	//错误处理 处理asset抛出的异常报错
	app.use(async (err, req, res, next) => {
    res.status(err.statusCode || 500).send({
      message: err.message
    })
  })
	```

- token需要一个密钥'secret'  这个密钥作为全局属性存放在了server/index.js中 

	```js
	//token的密钥
	app.set('secret', 'i2u34y12oi3u4y8')
	```

- 在校验用户名和密码是否正确后 如果校验出错  后台会返回错误信息 这个信息一般会全局捕获 意思就是通过axios进行错误响应拦截
- 但如果返回401表示登陆出错  会跳转到登陆页面进行重新登陆 这里用到了vue和router对象 这里修改的admin的http.js

	```js
	//通用的错误响应拦截
	http.interceptors.response.use(res => {
	  return res
	}, err => {
	  if (err.response.data.message) {
	    Vue.prototype.$message({
	      type: 'error',
	      message: err.response.data.message
	    })
	    
	    if (err.response.status === 401) {
	      router.push('/login')
	    }
	  }
	  
	  return Promise.reject(err)
	})
	```	
	
- 最后更新一下Login.vue的登陆请求 将返回的token存储在 localStorage 下次直接用token就可以请求数据了 	

	```js
	async login(){
    const res = await this.$http.post('login', this.model)
    // sessionStorage.token = res.data.token
    localStorage.token = res.data.token
    this.$router.push('/')
    this.$message({
      type: 'success',
      message: '登录成功'
    })
  }
	```
	
### 17.服务端登录校验

- 服务端的后台需要登录限制  每个接口数据都需要登陆后才可以操作和查看  需要通过token对服务端的后台进行限制
- 一般需要中间件来处理  处理的方法是每次请求接口都要验证token 正确的话才可以访问接口  这个中间件要写在app.use()中

	```js
	async (req, res, next) => {
    const token = String(req.headers.authorization || '').split(' ').pop()
    assert(token, 401, '请先登录')
    const { id } = jwt.verify(token, req.app.get('secret'))
    assert(id, 401, '请先登录')
    req.user = await AdminUser.findById(id)
    assert(req.user, 401, '请先登录')
    await next()
  }
	```
	
- 后台请求的这个token是前台通过axios来添加请求头的方式传递给后台的  这个拦截器是每通过axios发送请求都会拦截添加请求头  设置在前台的http.js中

	```js
	//拦截器 就是给请求头添加参数token 在每次请求时传递token给后台
	http.interceptors.request.use(function (config) {
	  // Do something before request is sent
	  if (localStorage.token) {
	    config.headers.Authorization = 'Bearer ' + localStorage.token
	  }
	  return config;
	}, function (error) {
	  // Do something with request error
	  return Promise.reject(error);
	})
	```
 
- 除了访问接口需要使用校验token外 上传文件接口也需要用到校验token 将token方法进行封装方便调用 一个是校验token  一个是格式化字符的
- 老师这里先写在了routes/index.js文件内 后来又创建了routes平级文件夹 middleware/auth.js  middleware/auth.js 解耦抽离
	
	```js
	//用来校验token的
	module.exports = options => {
	  const assert = require('http-assert')
	  const jwt = require('jsonwebtoken')
	  const AdminUser = require('../models/AdminUser')
	
	  return async (req, res, next) => {
	    const token = String(req.headers.authorization || '').split(' ').pop()
	    assert(token, 401, '请先登录')
	    const { id } = jwt.verify(token, req.app.get('secret'))
	    assert(id, 401, '请先登录')
	    req.user = await AdminUser.findById(id)
	    assert(req.user, 401, '请先登录')
	    await next()
	  }
	}
	//用来格式化字符的
	module.exports = options => {
	  return async (req, res, next) => {
	    const modelName = require('inflection').classify(req.params.resource)
	    req.Model = require(`../models/${modelName}`)
	    next()
	  }
	}
	```
 
- 最后登陆校验的中间件很简单 同时上传接口处理也要添加一个  要加括号调用 因为函数用了return

	```js
	// 登录校验中间件
	const authMiddleware = require('../../middleware/auth')
  const resourceMiddleware = require('../../middleware/resource')
  app.use('/admin/api/rest/:resource', authMiddleware(), resourceMiddleware(), router)
  
  //处理图片上传请求
  app.post('/admin/api/upload', authMiddleware(), upload.single('file'), async (req, res) => {
		//获取图片上传的信息  添加一个url返回去
    const file = req.file
    file.url = `http://localhost:3000/uploads/${file.filename}`
    res.send(file)
  })
	```
	
### 18.客户端路由限制 (beforeEach, meta)

- 虽然在后台做了登录校验 但在没有接口请求的数据上传界面 是不会验证token进行跳转的  这需要我们对客户端没有发生请求就可以访问的页面进行限制
- 通过router路由进行页面的访问限制   给需要公开访问的页面添加 meta: { isPublic: true } 更改后的logon路由配置
	
	```js
	{ path: '/login', name: 'login', component: Login, meta: { isPublic: true } },
	```
 
- 添加路由守卫 更改两个方面 一个是路由不是直接返回而是通过守卫之后返回  一个是通过router.beforeEach检测是否为开放页面

	```js
	const router = new Router
	
	router.beforeEach((to, from ,next) => {
		//如果进入到不是公开访问的页面都要跳转到登录页
	  if (!to.meta.isPublic && !localStorage.token) {
	    return next('/login')
	  }
	  next()
	})
	export default router
	```

### 19.上传文件的登录校验 (el-upload, headers)

- 在经过登陆校验后 会出现上传图片上传不了的情况 原因是ElementUI的自带上传方法不是axios的上传带不了token 而后台没有token不给权限
- 解决方法 在main.js中全局添加mixin方法  在上传的组件内部通过headers绑定方法传递token 

 	```js
	//全局使用的mixin
	Vue.mixin({
	  computed: {
	    uploadUrl(){
	      return this.$http.defaults.baseURL + '/upload'
	    }
	  },
	  methods: {
	    getAuthHeaders(){
	      return {
	        Authorization: `Bearer ${localStorage.token || ''}`
	      }
	    }
	  }
	})
	```
	
- ItemEdit.vue组件内 更改action和headers

	```html
	<el-upload
	  class="avatar-uploader"
	  :action="uploadUrl"
	  :headers="getAuthHeaders()"
	  :show-file-list="false"
	  :on-success="afterUpload">
	  <img v-if="model.icon" :src="model.icon" class="avatar">
	  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
	</el-upload>
	```
	
- admin后台开发到此完毕


## 三、移动端网站

1. "工具样式"概念和 SASS (SCSS)
1. 样式重置
1. 网站色彩和字体定义 (colors, text)
1. 通用flex布局样式定义 (flex)
1. 常用边距定义 (margin, padding)
1. 主页框架和顶部菜单
1. 首页顶部轮播图片 (vue swiper)
1. 使用精灵图片 (sprite)
1. 使用字体图标 (iconfont)
1. 卡片组件 (card)
1. 列表卡片组件 (list-card, nav, swiper)
1. 首页新闻资讯-数据录入(+后台bug修复)
1. 首页新闻资讯-数据接口
1. 首页新闻资讯-界面展示
1. 首页英雄列表
1. 新闻详情页
1. 英雄详情页

## 四、发布和部署 (阿里云)

1. 生产环境编译
1. 购买域名和服务器
1. 域名解析
1. Nginx 安装和配置
1. MongoDB数据库的安装和配置
1. git 安装、配置ssh-key
1. Node.js 安装、配置淘宝镜像
1. 拉取代码，安装pm2并启动项目
1. 配置 Nginx 的反向代理

## 五、进阶
1. 使用免费SSL证书启用HTTPS安全连接
1. 使用阿里云OSS云存储存放上传文件

 
 
##项目重点

###中间件的使用 
- 中间件的关键点是要包含三个参数  req,res next 然后在执行末尾执行next() 表示后续的方法参数也要执行 
###### 通过express引入中间件处理有两处地方
- 一处是对后台CRUD的操所的处理 主要用来过滤请求的接口参数:id 
- async (req,res,next) => {}
- 由于不是专门的req请求操作 需要通过中间件的形式 获取到req.params的参数 req.params.resource 平时只能在请求接口时获取到
- 将请求的参数挂载到req上 通过req.Model的形式 获取每次请求的参数路径  这个参数路径和mongodb的集合名是一样的

###### 一处是后台处理图片上传时 
- 由于express没有图片上传的功能 所以需要插件multer共同操作完成图片上传
- 上传的地址为multer({dest:__dirname+'../../uploads'})  意思是上传到uploads文件夹下
- 在前台时 图片上传会直接通过 action属性进行上传 路径为baseURL/upload
- upload.single('file')表示单个文件的上传  在req上绑定属性file 这个属性就是上传的图片路径对象
- 最后通过res.send(file) 返回这个路径 返回后就是显示在前台上传区域的那个图片  那个图片不是前台直接获取的 而是用后台返回过去的

### Object.assign()的使用
- 如果从后台获取数据时 获取的是三层数据 意思就是第二层数据可能没有 还要获取第三层数据时 项目会报错
- 这时需要在data中定义第二层数据的默认空对象 可以避免因为没有第二层数据而报错
- 如果从后台获取的数据通过data中的空数据接收时 还要注意后台返回的数据字段会覆盖data中空数据的字段
- 这时需要通过Object.assign() 避免data空数据的自段被后台返回的数据对象覆盖
- Object.assign({},this.form,res.data) 将this.form和res.data都添加到空对象中形成一个新的对象

### 管理员管理 对后台权限的限制

- 管理员的创建和密码的创建与其他分类创建一样
- 密码的保存需要进行散列保存 但只能散列一次 防止改动的时候散列回来  
- 服务端的登陆校验
- 对数据请求的限制 
- 如果没有给后台传入token 则限制访问请求
- 在请求接口时 通过中间件来限制接口的访问及数据返回  传递的token正确的话  则返回正确的数据
- 客户端的路由限制





















































