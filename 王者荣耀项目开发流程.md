
###Vue-cli3.0+Element UI + NodeJs(Express+mongoose)+Mongodb全栈开发王者荣耀手机站

###	前台与后台与服务器的关系
- 前台是web前端主要的开发场所
- 后台不仅仅是js处理文件 也要有后台页面  这个后台页面也是通过前端技术vue+Element搭建的
- 前台页面和后台页面均可以对后台js处理文件进行增删改查的请求  但后台页面控制前台页面的文章 列表渲染结果   就像dede一样

- 对后台路由的控制   对于项目接口比较多的情况 需要对路由router的接口进行封装处理
- 创建router文件夹专门存放对路由接口的处理
- 创建admin文件夹  表示处理后端的路由请求
- 对后台mongoose的控制 对于数据库的请求封装为两部分 
- 一部分是对数据库的增删改查工作 增删改查和 mongoose的创建工作    在文件夹plugins/db.js中
- 一部分是对数据库的模型创建工作 Schema的创建与联查 在文件夹models/中
- mongodb联查一般是通过相互关联的_id进行关联联查的  

##

## 一、 入门

1.项目介绍

2.项目技术选型
```bash
插件安装 vue-cli3.0 node mongodb

node.js 地址:https://nodejs.org/en/

npm     淘宝镜像:http://npm.taobao.org/

vue-cli3.0 npm i -g @vue/cli

mongodb 地址:https://www.mongodb.com/ 注意下载Server服务器版本→选择版本 系统  类型→选择MSI安装版

编辑器 		VSCode HBuilder

```
3. 初始化项目
> READNE.md 项目介绍文档

> LICENSE		项目开源协议

> .gitignore git忽略文件

## 三端项目创建
- mkdir server     创建服务端
- vue create web   创建web端		选择默认配置
- vue create admin 创建管理后台	选择默认配置

### 前台文件夹为 web

###	后台文件夹为 admin
- 安装Element Ui组件
- 安装router  路由
- 安装axios   ajax请求库
- 安装vue2 editor 安装富文本编辑器

### 服务器文件夹为 server
- 安装express
- 安装mongoose
- 安装cors   允许跨域请求的方法
- 安装inflection 处理接口的大小写和加s负数后缀
- 安装multer 处理图片资源上传
- 安装 nodemon 方便开启node后台服务		npm i nodemon --save
- 安装 bcrypt 对用户的密码进行散列加密
- 安装jsonwebtoken 向浏览器返回一个token验证  和session一样
- 安装http-assert 用来处理错误请求的返回

#### 初始化后台项目
- npm init -y 生成package.json文件
- 在server.js目录下生成index.js文件夹
- 在package.json文件中配置  "scripts":
	```js
	
  "serve": "nodemon index.js",
  
	```
- 通过 npm run serve 启动服务端接口
	
## 二、 管理后台

1. 基于Element UI的后台管理基础界面搭建
> 项目前台和后台的页面渲染都是通过vue+Element|实现的
- cd admin
- vue add element 
- vue add router
> 引入 Element Ui的 布局容器container  在src下的 views文件新建Main.vue组件存放整体布局 

- 在router.js文件中配置路由
	```js
	import Main from './views/Main.vue'
	{
    path: '/',
    name: 'main',
    component: Main
  },
	```
	
- 在Main.vue组件中设置容器的宽度和边框
	```js
	<el-container style="height: 100vh;">
	```

### 1. 创建分类

- 将导航一变为内容管理→分组该为分类→新建分类 分类列表
	```js
	<el-menu-item-group>
    <template slot="title">分类</template>
    <el-menu-item index="1-1">新建分类</el-menu-item>
    <el-menu-item index="1-2">分类列表</el-menu-item>
  </el-menu-item-group>
	```
- 给<el-menu>标签添加router属性 使其变成一个可点击的路由导航
	```js
	<el-menu router :default-openeds="['1', '3']">
	
	```
- 修改<el-menu>下的<el-menu-item>标签 使其成为一个路由导航
	```js
	<el-menu-item index="/categories/create">新建分类</el-menu-item>
	<el-menu-item index="/categories/list">分类列表</el-menu-item>
	```

- 创建CategoryEdit.vue组件 存放添加列表相关操作
- 直接绑定了提交事件 save 并为表单设置了双向绑定  v-model="model.name"
	
	```html
	<template>
		<div class="about">
			<h1>新建分类</h1>
			<el-form label-width="120px" @submit.native.prevent="save">
				<el-form-item label="名称">
			    <el-input v-model="model.name"></el-input>
			  </el-form-item>
			  <el-form-item>
			    <el-button type="primary" native-type="submit">保存</el-button>
			  </el-form-item>
			</el-form> 
		</div>
	</template>
	
	<script>
		export default {
			data(){
				return {
					model: {},
				}
			},
			async save(){
				
			}
		}
	</script>
	```
	
- 在router中引入CategoryEdit.vue组件并挂载Main下
	```js
	import CategoryEdit from './views/CategoryEdit.vue'
	children: [
  	{ path: '/categories/create', component: CategoryEdit },
  ]
  ```
  
- 修改Main.vue中的 <el-main>标签将其内容更改为路由容器 就是右侧的区域
	```html
	<el-main>
  	<router-view></router-view>
    <!--<el-table :data="tableData">
      <el-table-column prop="date" label="日期" width="140">
      </el-table-column>
      <el-table-column prop="name" label="姓名" width="120">
      </el-table-column>
      <el-table-column prop="address" label="地址">
      </el-table-column>
    </el-table>-->
  </el-main>
	```
	
- 安装axios请求数据  创建http.js 集中处理axios插件的请求
	```js
	//引入axios
	import axios from 'axios'
	
	//创建一个axios实例
	const http = axios.create({
		//指向后台的接口地址
	  baseURL: 'http://localhost:3000/admin/api'
	})
	
	//默认导出
	export default http
	```
	
- 在main.js中引入http.js 并将其中的请求方法挂在到vue的原型上 这样可以通过$http使用http.js中的方法了
	```js
	import http from './http'
	Vue.prototype.$http = http	
	```
- server后台开发
> 安装后台需要用到的插件 	npm i express@next mongoose cors 
- 搭建基于express最基本的http请求
	```js
	//引入express
	const express = require('express')
	
	//创建express实例
	const app = express()
	
	//开启端口
	app.listen(3000,()=>{
		console.log('http://localhost:3000')
	})
	```
- 创建routes文件夹  用来处理分类相关的路由  admin是后端路由 web是前端路由
> 创建一个最基本的路由接口请求	
	```js
	module.exports = app => {
		//引入express使用它的子路由Router()	
		const express = require('express')
		const router = express.Router()	
		
		//处理接口请求
		router.post('/catagories', async (req,res) => {
			
		})
		
		app.use('/admin/api',router)
	}
	```
- 使用mongodb数据库 对数据库的请求也进行模块化处理 避免耦合度过高
> 创建plugins/db.js文件夹用来处理数据库连接请求
	```js
	//连接数据库
	module.exports = app => {
	  const mongoose = require("mongoose")
	  mongoose.connect('mongodb://127.0.0.1:27017/node-vue-moba', {
	    useNewUrlParser: true
	  })
		//
	  
	}
	```
- 将server端处理后台接口请求和数据库连接的方法都挂在到server/index.js上
	```js
	//引入后端路由和数据库
	require('./routes/admin')(app)
	require('./plugins/db')(app)
	```	
- 创建mongodb模型 方便往数据库中存放数据
> 新建models文件夹 这里面存放的就是每个集合的模型规则 文件名就是集合的名字
- 先建一个Category.js文件用来指定分类数据的存放规则
	```js
	const mongoose = require('mongoose')
	
	const schema = new mongoose.Schema({
	  name: { type: String },
	})
	
	module.exports = mongoose.model('Category', schema)
	```
- 在routes/admin/index.js中引入这个集合规则
	```js
	const Category = require('../../models/Category')
	```
- 接入了集合规则以后就可以存储数据了	
	```js
	//存储分类数据
	router.post('/categories', async (req,res) => {
		const model = await Category.create(req.body)
		res.send(model)
	})
	```
- 完善前端页面对这个接口的请求写法 用element ui的this.$message提示一下保存成功
	```js
	async save(){
		const res = await this.$http.post('categories', this.model)
		this.$router.push('/categories/list')
		this.$message({
      type: 'success',
      message: '保存成功'
    })
	}
	```	
- 开启admin服务器  开启server服务器 开启mongodb试一下接口通不通
> 通的话此时已经跳转到了列表页 下面我们开始列表页的开发

### 2. 分类列表

- 创建分类列表页面 CategoryList.vue 并将其挂在到路由中
	```js
	import CategoryList from './views/CategoryList.vue'
	children: [
  	{ path: '/categories/create', component: CategoryEdit },
  	{ path: '/categories/list', component: CategoryList },
  ]
  ```	
- 实现CategoryList.vue dom渲染 就是之前Main.vue右侧的那个列表样式再从后台获取一下存储的列表数据
	```js
	<template>
		<div class="about">
			<h1>分类列表</h1>
			<el-table :data="items">
	      <el-table-column prop="_id" label="ID" width="230">
	      </el-table-column>
	      <el-table-column prop="name" label="分类名称">
	      </el-table-column>
	    </el-table>
		</div>
	</template>
	
	<script>
		export default {
			data(){
				return {
					items:[]
				}
			},
			created(){
				this.fetch()
			},
			methods:{
				async fetch(){
					 const res = await this.$http.get()
				}
			}
		}
	</script>
	```	
- 由于后端还没有写 所以现在再到后端路由里面去写这个接口
	```js
	//获取分类
	router.get('/categories', async (req,res) => {
		const items = await Category.find().limit(10)
		res.send(items)
	})
	```	
- 写完以后 在前台发送请求 并通过created生命周期函数去触发方法
	```js
	async fetch(){
		const res = await this.$http.get("categories")
		this.items = res.data
	}
	```	
- 写完之后看通不通 记得要打开数据库 server端 admin端
> 通了的话 是会直接跳转到分类列表显示分类条数 然后对列表进行改删操作

### 3. 修改分类

- 在Element Ui官网找到table表格选项 给分类列表添加"查看""删除"按钮 
	```html
	<el-table-column
    fixed="right"
    label="操作"
    width="100">
    <template slot-scope="scope">
      <el-button type="text" size="small">编辑</el-button>
    </template>
 	</el-table-column>
	```	
- 给<el-button>编辑按钮添加点击跳转  这个跳转通过scope.row._id 指定的详情页 这个scope.row就相当于v-for循环的那个item 
	```html
	<el-button type="text" size="small" 
	        	@click="$router.push(`/categories/edit/${scope.row._id}`)">编辑</el-button>
	```	
- 跳转的详情页还没有页面渲染  去路由中指定跳转的页面 并接收id参数 props的意思是将url带过来的参数通过props进行接收
	```js
	{ path: '/categories/edit/:id', component: CategoryEdit, props: true },
	```	
- 在CategoryEdit.vue内 这个id就是经过路由设置  从url传递过来的id 
	```js
	props:{
		id:{}
	},
	```	
- 如果CategoryEdit.vue内传入了这个id 那么就属于修改分类操作  这时h1标签需要根据是否传入id进行不同显示
	```html
	<h1>{{id ? '编辑' : '新建'}}分类列表</h1>
	```		
- 如果CategoryEdit.vue内传入了这个id 则需要对分类信息进行修改 在打开这个页面后 需要从后台获取这个根据id传过来的数据
> 获取这个数据有一个必要条件  就是要有了id之后才可以获取 而新建分类是没有id的 所以需要控制何时去获取
	```js
	created(){
		this.id && this.fetch()
	},
	```	
- this.fetch() 是从后台获取数据的方法  这个接口后台还没有写
> 需要在server/routes/admin/index.js路由中写这个接口请求
	```js
	//获取分类详情
	router.get('/categories/:id', async (req,res) => {
		const model = await Category.findById(req.params.id)
		res.send(model)
	})
	```	
- 前台完善这个this.fetch()方法请求
	```js
	async fetch(){
		const res = await this.$http.get(`categories/${this.id}`)
 		this.model = res.data
	}
	```	
- 写完之后看通不通 记得要打开数据库 server端 admin端
> 这样在获取了要修改的数据保存的时候 与之前的seve()方法逻辑发生冲突 之前的逻辑是新增数据 而现在是更改数据 所以也需要加判断条件
	```js
	async save(){
		let res
    if (this.id) {
      res = await this.$http.put(`categories/${this.id}`, this.model)
    } else {
      res = await this.$http.post('categories', this.model)
    }
    this.$router.push('/categories/list')
		this.$message({
      type: 'success',
      message: '保存成功'
    })
	}
	```		 
- 后端server/routes/admin/index.js路由跟着去写一个put方法 用来完成更该数据的请求	
	```js
	//更改分类
	router.put('/categories/:id', async (req, res) => {
    const model = await Category.findByIdAndUpdate(req.params.id, req.body)
    res.send(model)
  })
	```	
- 写完之后看通不通 记得要打开数据库 server端 admin端		
 
### 4. 删除分类

- 在	CategoryList.vue 页面的<el-table-column>内添加一个<el-button>删除按钮 绑定的是remove事件 传入的当前项
	```html
	<el-button type="text" size="small" 
	        	@click="remove(scope.row)">删除</el-button>
  })
	```
- 在mothods中实现remove()方法删除数据时 需要添加一个Message Box拦截提示框 防止误操作 如果确定删除 请求后台接口删除指定数据
> 如果不加.catch() 控制台会报cancel警告  加上好看一些 最后重新加载分类列表数据 更新栏目
	```js
	async remove(row){
    this.$confirm(`是否确定要删除分类 "${row.name}"`, "提示", {
      confirmButtonText: "确定",
      cancelButtonText: "取消",
      type: "warning"
    }).then(async () => {
    	//请求的删除接口
      const res = await this.$http.delete(`categories/${row._id}`);
      this.$message({
        type: "success",
        message: "删除成功!"
      })
    }).catch(() => {
      this.$message({
        type: 'info',
        message: '已取消删除'
      });          
    })
    this.fetch()
	}
	```
- 后端server/routes/admin/index.js路由跟着去写一个delete方法  用来删除前台发送需要删除的数据id
	```js
	//删除分类
	router.delete('/categories/:id', async (req, res) => {
    await Category.findByIdAndDelete(req.params.id)
    res.send({
    	success:true
    })
  })
  ```
- 写完之后看通不通 记得要打开数据库 server端 admin端		
	
### 4. 子分类

- 刚才创建的都是一级分类  在一级分类下面还有二级分类甚至三级分类等子分类  关系上和父子组件类似
> 分类的关系主要体现在数据库中 在mongodb数据中 需要通过._id 进行相互关联 

- 实现CategoryEdit.vue中创建分类时添加上级分类  通过v-for循环循环到<el-select>中
	```html
	<!--上级分类-->
	<el-form-item label="上级分类">
    <el-select v-model="model.parent">
      <el-option v-for="item in parents" :key="item._id"
      :label="item.name" :value="item._id"></el-option>
    </el-select>
  </el-form-item>
  ```
- 上级分类就是我们添加的那些一级分类 需要在data中设置一个属性接收 然后从后台获取这些数据
	```js
	created(){
		this.fetchParents()
	}
	//获取上级分类
	async fetchParents(){
    const res = await this.$http.get('categories')
    this.parents = res.data
  }
  ```
- 由于router.post提交时多了一个parents字段 这个字段需要设置关联 在models/Category.js中需要添加一个父级分类的字段
> 这个parent规则的类型是一个._id 属性 关联的规则是Category 可以通过Category去找到这个ObjectId字段
 	```js
	parent: { type: mongoose.SchemaTypes.ObjectId, ref: 'Category' },
  ```
- 写完之后看通不通 记得要打开数据库 server端 admin端		

- 在CategoryList.vue添加上级分类字段 展示隶属的上级分类 
	```html
	<el-table-column prop="parent.name" label="上级分类">
      </el-table-column>
  ```
- 但展示出来的._id存储的id值数据 需要通过后台转义为字符串类型的数据方便查看
> populate() 表示关联 取出  意思就是如果字段里有关联字段 取出这个数据
	```js
	//获取分类
	router.get('/categories', async (req,res) => {
		const items = await Category.find().populate('parent').limit(10)
		res.send(items)
	})
  ```
- 写完之后看通不通 记得要打开数据库 server端 admin端		 

1. **通用 CRUD 接口**
- 设计一个通用的CRUD接口 用来处理多接口的通用请求
- 由于一个基本的项目后台涉及的增删改查都是类似相同的操作
- 所以我们在设计后台接口时 可以将其设计为一个通用的接口 将对后台的请求路径作为参数 比如.get('rest/hero') 将这个hero设置为:id
- 在后台接收这个参数时 格式为 app.use('/admin/api/rest/:resoruce',router)
- 根据传入的/:id(类似形参进行请求 这里是'resoruce') 达到多个接口匹配共用
- 这里的resoruce就是我们传入的id 同时这个ID也是mongodb集合的集合名 请求路径与集合名分别对应
- 这个id通过('inflection').classify的加工后 变成首字母大写加负数的格式 这个格式的名字就是mongodb的集合名
- 通过这个集合名与mongodb建立链接 就是接入mongodb的集合名 进行CRUD操作

1. 装备管理
1. 图片上传 (multer)

1. 英雄管理
1. 编辑英雄 (关联,多选,el-select, multiple)
1. 技能编辑

1. 文章管理
1. 富文本编辑器 (quill)

1. 首页广告管理

1. 管理员账号管理 (bcrypt)
1. 登录页面
1. 登录接口 (jwt,jsonwebtoken)
1. 服务端登录校验
1. 客户端路由限制 (beforeEach, meta)
1. 上传文件的登录校验 (el-upload, headers)

## 三、移动端网站

1. "工具样式"概念和 SASS (SCSS)
1. 样式重置
1. 网站色彩和字体定义 (colors, text)
1. 通用flex布局样式定义 (flex)
1. 常用边距定义 (margin, padding)
1. 主页框架和顶部菜单
1. 首页顶部轮播图片 (vue swiper)
1. 使用精灵图片 (sprite)
1. 使用字体图标 (iconfont)
1. 卡片组件 (card)
1. 列表卡片组件 (list-card, nav, swiper)
1. 首页新闻资讯-数据录入(+后台bug修复)
1. 首页新闻资讯-数据接口
1. 首页新闻资讯-界面展示
1. 首页英雄列表
1. 新闻详情页
1. 英雄详情页

## 四、发布和部署 (阿里云)

1. 生产环境编译
1. 购买域名和服务器
1. 域名解析
1. Nginx 安装和配置
1. MongoDB数据库的安装和配置
1. git 安装、配置ssh-key
1. Node.js 安装、配置淘宝镜像
1. 拉取代码，安装pm2并启动项目
1. 配置 Nginx 的反向代理

## 五、进阶
1. 使用免费SSL证书启用HTTPS安全连接
1. 使用阿里云OSS云存储存放上传文件

 
 
##项目重点

###中间件的使用 

### 通过express引入中间件处理有两处地方
- 一处是对后台CRUD的操所的处理 主要用来过滤请求的接口参数:id 
- async (req,res,next) => {}
- 由于不是专门的req请求操作 需要通过中间件的形式 获取到req.params的参数 req.params.resource 平时只能在请求接口时获取到
- 将请求的参数挂载到req上 通过req.Model的形式 获取每次请求的参数路径  这个参数路径和mongodb的集合名是一样的

### 一处是后台处理图片上传时 
- 由于express没有图片上传的功能 所以需要插件multer共同操作完成图片上传
- 上传的地址为multer({dest:__dirname+'../../uploads'})  意思是上传到uploads文件夹下
- 在前台时 图片上传会直接通过 action属性进行上传 路径为baseURL/upload
- upload.single('file')表示单个文件的上传  在req上绑定属性file 这个属性就是上传的图片路径对象
- 最后通过res.send(file) 返回这个路径 返回后就是显示在前台上传区域的那个图片  那个图片不是前台直接获取的 而是用后台返回过去的

### Object.assign()的使用
- 如果从后台获取数据时 获取的是三层数据 意思就是第二层数据可能没有 还要获取第三层数据时 项目会报错
- 这时需要在data中定义第二层数据的默认空对象 可以避免因为没有第二层数据而报错
- 如果从后台获取的数据通过data中的空数据接收时 还要注意后台返回的数据字段会覆盖data中空数据的字段
- 这时需要通过Object.assign() 避免data空数据的自段被后台返回的数据对象覆盖
- Object.assign({},this.form,res.data) 将this.form和res.data都添加到空对象中形成一个新的对象

### 管理员管理 对后台权限的限制

- 管理员的创建和密码的创建与其他分类创建一样
- 密码的保存需要进行散列保存 但只能散列一次 防止改动的时候散列回来  
- 服务端的登陆校验
- 对数据请求的限制 
- 如果没有给后台传入token 则限制访问请求
- 在请求接口时 通过中间件来限制接口的访问及数据返回  传递的token正确的话  则返回正确的数据
- 客户端的路由限制





















































